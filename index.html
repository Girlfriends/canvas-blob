<!DOCTYPE html>
<html>
<head>
	<title>Canvas Play</title>
	<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/paper.js/0.11.4/paper-core.min.js"></script>
</head>
<body>
<canvas id="canvas" width="800px" height="600px" style="{background-color: blue}"></canvas>
<link rel="stylesheet" href="style.css">
<script type="text/javascript">
	// Only executed our code once the DOM is ready.
	window.onload = function() {

		// Get a reference to the canvas object
		var canvas = document.getElementById('canvas');
		// Create an empty project and a view for the canvas:
		paper.setup(canvas);

		var pointsWeLike = [
			554.1627744872745, 300,
			534.7928267984526, 386.6260897855751,
			452.2166233742444, 414.3384563002629,
			380.79496890149267, 433.57392527677905,
			303.01842097507574, 411.92270855319634,
			289.6131995475023, 332.41248908355425,
			286.3928847594946, 266.64194117908556,
			308.0667895440347, 193.9034193537076,
			383.79737582230956, 187.30827354053258,
			446.87871510923884, 197.3499324053576,
			496.78370599085247, 237.80088893394617
		];

		var rootSpeed = 0.02;
		var speedOffset = 0;
		var radius = 140;
		var width, height, center;
		var points = 11;
		var phases;
		var smooth = true;
		var path = new paper.Path();
		var myText;
		var mousePos = {
			x: paper.view.center.x,
			y: paper.view.center.y
		};
		var pathHeight = mousePos.y;
		var tool = new paper.Tool();
		var isFindingPointsWeLike = false;
		path.fillColor = 'black';
		initializePath();

		function initializePath() {
			center = paper.view.center;
			width = paper.view.size.width;
			height = paper.view.size.height;
			path.segments = [];
			phases = [];

			for (var i=0; i<points; i++) {
				var angle = Math.PI * 2 * (i/points);
				var x = center.x + Math.cos(angle) * radius;
				var y = center.y + Math.sin(angle) * radius;
				var point = new paper.Point(x, y);
				path.add(point);
				phases.push( (i + i % 4) * 100 );
			}

			path.closed = true;
			path.fullySelected = false;

			var pointTextLocation = center;
			if (!myText) myText = new paper.PointText(pointTextLocation);
			myText.fillColor = 'white';
			myText.content = '♥ω♥';
			myText.fontSize = '100px';
			myText.fontFamily = 'Futura';
			myText.fontWeight = 'bold';
			myText.position.x -= myText.bounds.width/2;
			myText.position.y += myText.bounds.height/4;
		}

		function animateDriftToNicePoints(event) {
			for (var i = 0; i < points; i++) {
				path.segments[i].point.x = path.segments[i].point.x * 0.9 + pointsWeLike[i*2] *0.1;
				path.segments[i].point.y = path.segments[i].point.y * 0.9 + pointsWeLike[i*2+1] *0.1;
			}
		}

		function animateWiggle(event) {
			var speed = (rootSpeed + speedOffset);
			speedOffset *= 0.95;
			pathHeight += (Math.abs(center.y - mousePos.y) + (speed - rootSpeed) * 500 - pathHeight) / 10;

			for (var i = 0; i < points; i++) {
				phases[i] += speed * 1;
				var sinHeight = Math.sin(phases[i]) * pathHeight;
				var delta = Math.sin(phases[i] + Math.sin(phases[i])) * sinHeight;
				delta *= 0.2;

				var angle = Math.PI * 2 * (i/points);
				var x = center.x + Math.cos(angle) * (radius + delta);
				var y = center.y + Math.sin(angle) * (radius + delta);

				path.segments[i].point.x = x;
				path.segments[i].point.y = y;
			}
			if (smooth)
				path.smooth({ type: 'continuous' });

			var cx = 0;
			var cy = 0;

			for (var i = 0; i < points; i++) {
				cx += path.segments[i].point.x;
				cy += path.segments[i].point.y;
			}

			// path.matrix.reset();

			// path.rotate(event.count * -0.25);

			myText.matrix.reset();

			cx /= points;
			cy /= points;

			var mouseNorm = Object.assign({}, mousePos);
			mouseNorm.x = (2 * mousePos.x / width - 1);
			mouseNorm.y = (2 * mousePos.y / height - 1);

			var skewDegrees = {
				x: -mouseNorm.x * (mouseNorm.y * 20),
				y: mouseNorm.x * (-(mouseNorm.y * mouseNorm.y) * 20)
			};

			myText.skew(skewDegrees);
			myText.scale(1.0 - (speed - rootSpeed));
			// myText.shear(skewDegrees);

			myText.position.x = cx;
			myText.position.y = cy;
		}

		paper.view.onFrame = function(event) {

			if (isFindingPointsWeLike) {
				animateDriftToNicePoints(event);
			} else {
				animateWiggle(event);
			}
		}

		tool.onMouseMove = function(event) {
			mousePos.x = (mousePos.x + event.point.x) / 2;
			mousePos.y = (mousePos.y + event.point.y) / 2;
		}

		tool.onMouseDown = function(event) {
			// smooth = !smooth;
			// if (!smooth) {
			// 	// If smooth has been turned off, we need to reset
			// 	// the handles of the path:
			// 	for (var i = 0, l = path.segments.length; i < l; i++) {
			// 		var segment = path.segments[i];
			// 		segment.handleIn = segment.handleOut = null;
			// 	}
			// }

			speedOffset = 0.5;
		}

		paper.view.onMouseEnter = function(event) {
			isFindingPointsWeLike = false;
			console.log("Tracking the mouse");
		}

		paper.view.onMouseLeave = function(event) {
			// isFindingPointsWeLike = true;
			console.log("Returning to points we like");
		}

		// Reposition the path whenever the window is resized:
		function onResize(event) {
			initializePath();
		}
	}
</script>
</body>
</html>